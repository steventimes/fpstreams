{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"fpstreams","text":"<p>A robust, type-safe functional programming library for Python.</p> <p><code>fpstreams</code> brings the power of Java Streams, Rust Results, and JavaScript Array methods to Python. It provides a fluent interface for data processing, null safety, and error handling without the boilerplate, all while remaining fully typed for IDE autocompletion.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Fluent Streams: Lazy evaluation chains (<code>map</code>, <code>filter</code>, <code>reduce</code>, <code>zip</code>)</li> <li>Null Safety: <code>Option</code> monad to eliminate <code>None</code> checks.</li> <li>Error Handling: <code>Result</code> monad (Success/Failure) to replace ugly <code>try/except</code> blocks.</li> <li>Powerful Collectors: Grouping, partitioning, and joining made simple.</li> <li>Functional Tools: Utilities like <code>pipe</code> and <code>curry</code> for cleaner composition.</li> </ul>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install fpstreams\n</code></pre>"},{"location":"#usage-example","title":"Usage Example","text":""},{"location":"#streams-using-name-from-java","title":"Streams (using name from Java)","text":"<pre><code>from fpstreams import Stream\n\ndata = [\n    {\"name\": \"Alice\", \"role\": \"admin\", \"age\": 30},\n    {\"name\": \"Bob\", \"role\": \"dev\", \"age\": 25},\n    {\"name\": \"Charlie\", \"role\": \"admin\", \"age\": 45}\n]\n\n# Get names of admins whose age is over 25, sorted alphabetically\nnames = (\n    Stream(data)\n    .filter(lambda u: u[\"role\"] == \"admin\")\n    .filter(lambda u: u[\"age\"] &gt; 25)\n    .map(lambda u: u[\"name\"].upper())\n    .sorted()\n    .to_list()\n)\n# Output: ['ALICE', 'CHARLIE']\n</code></pre>"},{"location":"#null-safety-with-option","title":"Null Safety with <code>Option</code>","text":"<pre><code>from fpstreams import Stream\n\n# Find the first user named \"Steven\" (who doesn't exist)\nemail = (\n    Stream(data)\n    .filter(lambda u: u[\"name\"] == \"Steven\")\n    .find_first()               # Returns Option[User]\n    .map(lambda u: u[\"email\"])  # Skipped because Option is empty\n    .or_else(\"default@example.com\")\n)\n</code></pre>"},{"location":"#error-handling-with-result","title":"Error handling with <code>Result</code>","text":"<pre><code>from fpstreams import Result\n\ndef risky_parsing(value):\n    return int(value) # Might crash if value is not a number\n\n# Safe execution\nresult = (\n    Result.of(lambda: risky_parsing(\"invalid\"))\n    .map(lambda x: x * 2)\n    .on_failure(lambda e: print(f\"Parsing failed: {e}\")) # Logs error\n    .get_or_else(0) # Returns 0 instead of crashing\n)\n</code></pre>"},{"location":"#collectors","title":"Collectors","text":"<p>grouping data using collectors</p> <pre><code>from fpstreams import Stream, Collectors\n\nfruits = [\"apple\", \"avocado\", \"banana\", \"blueberry\", \"cherry\"]\n\n# Group fruits by their first letter\ngrouped = (\n    Stream(fruits)\n    .collect(Collectors.grouping_by(lambda s: s[0]))\n)\n# Output: {'a': ['apple', 'avocado'], 'b': ['banana', 'blueberry'], 'c': ['cherry']}\n</code></pre>"},{"location":"#infinite-streams-lazy-evaluation","title":"Infinite Streams &amp; Lazy Evaluation","text":"<p>Process massive datasets efficiently. Operations are only executed when needed.</p> <pre><code>def infinite_counter():\n    n = 0\n    while True:\n        yield n\n        n += 1\n\n# Take only the first 10 even numbers\nevens = (\n    Stream(infinite_counter())\n    .filter(lambda x: x % 2 == 0)\n    .limit(10)\n    .to_list()\n)\n</code></pre>"},{"location":"#project-structure","title":"Project Structure","text":"<p>1.<code>Stream</code>: The core wrapper for iterables.\\ 2.<code>Option</code>: A container for optional values.\\ 3.<code>Result</code>: A container for operations that may fail.\\ 4.<code>Collectors</code>: Helper functions for aggregation.\\ 5.<code>functional</code>: Utilities like <code>pipe</code> and <code>curry</code></p>"},{"location":"reference/option/","title":"Option API","text":"<p>               Bases: <code>Generic[T]</code></p> <p>A container object which may or may not contain a non-null value. Replaces None checks.</p> Source code in <code>fpstreams\\option.py</code> <pre><code>class Option(Generic[T]):\n    \"\"\"\n    A container object which may or may not contain a non-null value.\n    Replaces None checks.\n    \"\"\"\n\n    def __init__(self, value: Union[T, None]):\n        self._value = value\n\n    @classmethod\n    def of(cls, value: T) -&gt; \"Option[T]\":\n        \"\"\"Returns an Option describing the given non-null value.\"\"\"\n        if value is None:\n            raise ValueError(\"Option.of() cannot be called with None. Use Option.of_nullable() instead.\")\n        return cls(value)\n\n    @classmethod\n    def of_nullable(cls, value: Union[T, None]) -&gt; \"Option[T]\":\n        \"\"\"Returns an Option describing the given value, if non-null, otherwise returns an empty Option.\"\"\"\n        return cls(value)\n\n    @classmethod\n    def empty(cls) -&gt; \"Option[T]\":\n        \"\"\"Returns an empty Option instance.\"\"\"\n        return cls(None)\n\n    def is_present(self) -&gt; bool:\n        \"\"\"Returns True if there is a value present, otherwise False.\"\"\"\n        return self._value is not None\n\n    def is_empty(self) -&gt; bool:\n        \"\"\"Returns True if there is no value present, otherwise False.\"\"\"\n        return self._value is None\n\n    def if_present(self, action: Callable[[T], None]) -&gt; None:\n        \"\"\"If a value is present, invokes the specified consumer with the value, otherwise does nothing.\"\"\"\n        if self._value is not None:\n            action(self._value)\n\n    def filter(self, predicate: Callable[[T], bool]) -&gt; \"Option[T]\":\n        \"\"\"\n        If a value is present and matches the given predicate, return an Option describing the value,\n        otherwise return an empty Option.\n        \"\"\"\n        if self._value is None:\n            return self\n\n        if predicate(self._value):\n            return self\n        return Option.empty()\n\n    def map(self, mapper: Callable[[T], R]) -&gt; \"Option[R]\":\n        \"\"\"\n        If a value is present, apply the provided mapping function to it, \n        and if the result is non-null, return an Option describing the result.\n        \"\"\"\n        if self._value is None:\n            return Option.empty()\n\n        result = mapper(self._value)\n        return Option.of_nullable(result)\n\n    def flat_map(self, mapper: Callable[[T], \"Option[R]\"]) -&gt; \"Option[R]\":\n        \"\"\"\n        If a value is present, apply the provided Option-bearing mapping function to it, \n        return that result, otherwise return an empty Option.\n        \"\"\"\n        if self._value is None:\n            return Option.empty()\n\n        return mapper(self._value)\n\n    def or_else(self, other: T) -&gt; T:\n        \"\"\"Return the value if present, otherwise return other.\"\"\"\n        return self._value if self._value is not None else other\n\n    def or_else_get(self, supplier: Callable[[], T]) -&gt; T:\n        \"\"\"Return the value if present, otherwise invoke other and return the result of that invocation.\"\"\"\n        return self._value if self._value is not None else supplier()\n\n    def or_else_throw(self, exception_supplier: Callable[[], Exception]) -&gt; T:\n        \"\"\"Return the contained value, if present, otherwise throw an exception to be created by the provided supplier.\"\"\"\n        if self._value is not None:\n            return self._value\n        raise exception_supplier()\n\n    def __repr__(self) -&gt; str:\n        return f\"Option({self._value})\" if self._value is not None else \"Option.empty\"\n\n    def __bool__(self) -&gt; bool:\n        return self._value is not None\n</code></pre>"},{"location":"reference/option/#fpstreams.Option.empty","title":"<code>empty()</code>  <code>classmethod</code>","text":"<p>Returns an empty Option instance.</p> Source code in <code>fpstreams\\option.py</code> <pre><code>@classmethod\ndef empty(cls) -&gt; \"Option[T]\":\n    \"\"\"Returns an empty Option instance.\"\"\"\n    return cls(None)\n</code></pre>"},{"location":"reference/option/#fpstreams.Option.filter","title":"<code>filter(predicate)</code>","text":"<p>If a value is present and matches the given predicate, return an Option describing the value, otherwise return an empty Option.</p> Source code in <code>fpstreams\\option.py</code> <pre><code>def filter(self, predicate: Callable[[T], bool]) -&gt; \"Option[T]\":\n    \"\"\"\n    If a value is present and matches the given predicate, return an Option describing the value,\n    otherwise return an empty Option.\n    \"\"\"\n    if self._value is None:\n        return self\n\n    if predicate(self._value):\n        return self\n    return Option.empty()\n</code></pre>"},{"location":"reference/option/#fpstreams.Option.flat_map","title":"<code>flat_map(mapper)</code>","text":"<p>If a value is present, apply the provided Option-bearing mapping function to it,  return that result, otherwise return an empty Option.</p> Source code in <code>fpstreams\\option.py</code> <pre><code>def flat_map(self, mapper: Callable[[T], \"Option[R]\"]) -&gt; \"Option[R]\":\n    \"\"\"\n    If a value is present, apply the provided Option-bearing mapping function to it, \n    return that result, otherwise return an empty Option.\n    \"\"\"\n    if self._value is None:\n        return Option.empty()\n\n    return mapper(self._value)\n</code></pre>"},{"location":"reference/option/#fpstreams.Option.if_present","title":"<code>if_present(action)</code>","text":"<p>If a value is present, invokes the specified consumer with the value, otherwise does nothing.</p> Source code in <code>fpstreams\\option.py</code> <pre><code>def if_present(self, action: Callable[[T], None]) -&gt; None:\n    \"\"\"If a value is present, invokes the specified consumer with the value, otherwise does nothing.\"\"\"\n    if self._value is not None:\n        action(self._value)\n</code></pre>"},{"location":"reference/option/#fpstreams.Option.is_empty","title":"<code>is_empty()</code>","text":"<p>Returns True if there is no value present, otherwise False.</p> Source code in <code>fpstreams\\option.py</code> <pre><code>def is_empty(self) -&gt; bool:\n    \"\"\"Returns True if there is no value present, otherwise False.\"\"\"\n    return self._value is None\n</code></pre>"},{"location":"reference/option/#fpstreams.Option.is_present","title":"<code>is_present()</code>","text":"<p>Returns True if there is a value present, otherwise False.</p> Source code in <code>fpstreams\\option.py</code> <pre><code>def is_present(self) -&gt; bool:\n    \"\"\"Returns True if there is a value present, otherwise False.\"\"\"\n    return self._value is not None\n</code></pre>"},{"location":"reference/option/#fpstreams.Option.map","title":"<code>map(mapper)</code>","text":"<p>If a value is present, apply the provided mapping function to it,  and if the result is non-null, return an Option describing the result.</p> Source code in <code>fpstreams\\option.py</code> <pre><code>def map(self, mapper: Callable[[T], R]) -&gt; \"Option[R]\":\n    \"\"\"\n    If a value is present, apply the provided mapping function to it, \n    and if the result is non-null, return an Option describing the result.\n    \"\"\"\n    if self._value is None:\n        return Option.empty()\n\n    result = mapper(self._value)\n    return Option.of_nullable(result)\n</code></pre>"},{"location":"reference/option/#fpstreams.Option.of","title":"<code>of(value)</code>  <code>classmethod</code>","text":"<p>Returns an Option describing the given non-null value.</p> Source code in <code>fpstreams\\option.py</code> <pre><code>@classmethod\ndef of(cls, value: T) -&gt; \"Option[T]\":\n    \"\"\"Returns an Option describing the given non-null value.\"\"\"\n    if value is None:\n        raise ValueError(\"Option.of() cannot be called with None. Use Option.of_nullable() instead.\")\n    return cls(value)\n</code></pre>"},{"location":"reference/option/#fpstreams.Option.of_nullable","title":"<code>of_nullable(value)</code>  <code>classmethod</code>","text":"<p>Returns an Option describing the given value, if non-null, otherwise returns an empty Option.</p> Source code in <code>fpstreams\\option.py</code> <pre><code>@classmethod\ndef of_nullable(cls, value: Union[T, None]) -&gt; \"Option[T]\":\n    \"\"\"Returns an Option describing the given value, if non-null, otherwise returns an empty Option.\"\"\"\n    return cls(value)\n</code></pre>"},{"location":"reference/option/#fpstreams.Option.or_else","title":"<code>or_else(other)</code>","text":"<p>Return the value if present, otherwise return other.</p> Source code in <code>fpstreams\\option.py</code> <pre><code>def or_else(self, other: T) -&gt; T:\n    \"\"\"Return the value if present, otherwise return other.\"\"\"\n    return self._value if self._value is not None else other\n</code></pre>"},{"location":"reference/option/#fpstreams.Option.or_else_get","title":"<code>or_else_get(supplier)</code>","text":"<p>Return the value if present, otherwise invoke other and return the result of that invocation.</p> Source code in <code>fpstreams\\option.py</code> <pre><code>def or_else_get(self, supplier: Callable[[], T]) -&gt; T:\n    \"\"\"Return the value if present, otherwise invoke other and return the result of that invocation.\"\"\"\n    return self._value if self._value is not None else supplier()\n</code></pre>"},{"location":"reference/option/#fpstreams.Option.or_else_throw","title":"<code>or_else_throw(exception_supplier)</code>","text":"<p>Return the contained value, if present, otherwise throw an exception to be created by the provided supplier.</p> Source code in <code>fpstreams\\option.py</code> <pre><code>def or_else_throw(self, exception_supplier: Callable[[], Exception]) -&gt; T:\n    \"\"\"Return the contained value, if present, otherwise throw an exception to be created by the provided supplier.\"\"\"\n    if self._value is not None:\n        return self._value\n    raise exception_supplier()\n</code></pre>"},{"location":"reference/result/","title":"Result API","text":"<p>               Bases: <code>Generic[T]</code></p> <p>A container for a value that represents either a successful result (Success) or a failure (Failure).  Replaces try/except blocks in functional pipelines.</p> Source code in <code>fpstreams\\result.py</code> <pre><code>class Result(Generic[T]):\n    \"\"\"\n    A container for a value that represents either a successful result (Success)\n    or a failure (Failure). \n    Replaces try/except blocks in functional pipelines.\n    \"\"\"\n\n    def __init__(self, value: Union[T, None], error: Union[Exception, None], is_success: bool):\n        self._value = value\n        self._error = error\n        self._is_success = is_success\n\n    @classmethod\n    def success(cls, value: T) -&gt; \"Result[T]\":\n        \"\"\"Creates a successful Result.\"\"\"\n        return cls(value, None, True)\n\n    @classmethod\n    def failure(cls, error: Exception) -&gt; \"Result[T]\":\n        \"\"\"Creates a failed Result.\"\"\"\n        return cls(None, error, False)\n\n    @classmethod\n    def of(cls, func: Callable[[], T]) -&gt; \"Result[T]\":\n        \"\"\"\n        Executes the provided function. \n        Returns Success(value) if it works, or Failure(exception) if it crashes.\n        \"\"\"\n        try:\n            return cls.success(func())\n        except Exception as e:\n            return cls.failure(e)\n\n    def is_success(self) -&gt; bool:\n        return self._is_success\n\n    def is_failure(self) -&gt; bool:\n        return not self._is_success\n\n    def map(self, mapper: Callable[[T], R]) -&gt; \"Result[R]\":\n        \"\"\"\n        If Success, applies the mapper to the value.\n        If Failure, returns the existing Failure (skips the mapper).\n        \"\"\"\n        if self._is_success:\n            try:\n                val = cast(T, self._value)\n                return Result.success(mapper(val))\n            except Exception as e:\n                return Result.failure(e)\n        else:\n            return Result.failure(cast(Exception, self._error))\n\n    def flat_map(self, mapper: Callable[[T], \"Result[R]\"]) -&gt; \"Result[R]\":\n        \"\"\"\n        If Success, returns the result of applying the mapper (which must return a Result).\n        If Failure, returns the existing Failure.\n        \"\"\"\n        if self._is_success:\n            try:\n                val = cast(T, self._value)\n                return mapper(val)\n            except Exception as e:\n                return Result.failure(e)\n        return Result.failure(cast(Exception, self._error))\n\n    def map_error(self, mapper: Callable[[Exception], Exception]) -&gt; \"Result[T]\":\n        \"\"\"\n        If Failure, allows you to transform the exception.\n        If Success, does nothing.\n        \"\"\"\n        if not self._is_success:\n            err = cast(Exception, self._error)\n            return Result.failure(mapper(err))\n        return self\n\n    def on_success(self, action: Callable[[T], None]) -&gt; \"Result[T]\":\n        \"\"\"Executes action if Success.\"\"\"\n        if self._is_success:\n            action(cast(T, self._value))\n        return self\n\n    def on_failure(self, action: Callable[[Exception], None]) -&gt; \"Result[T]\":\n        \"\"\"Executes action if Failure.\"\"\"\n        if not self._is_success:\n            action(cast(Exception, self._error))\n        return self\n\n    def get_or_else(self, default: T) -&gt; T:\n        \"\"\"Returns the value if Success, or the default value if Failure.\"\"\"\n        if self._is_success:\n            return cast(T, self._value)\n        return default\n\n    def get_or_throw(self) -&gt; T:\n        \"\"\"Returns the value if Success, otherwise raises the stored exception.\"\"\"\n        if self._is_success:\n            return cast(T, self._value)\n        raise cast(Exception, self._error)\n\n    def __repr__(self) -&gt; str:\n        if self._is_success:\n            return f\"Result.success({self._value})\"\n        return f\"Result.failure({self._error})\"\n</code></pre>"},{"location":"reference/result/#fpstreams.Result.failure","title":"<code>failure(error)</code>  <code>classmethod</code>","text":"<p>Creates a failed Result.</p> Source code in <code>fpstreams\\result.py</code> <pre><code>@classmethod\ndef failure(cls, error: Exception) -&gt; \"Result[T]\":\n    \"\"\"Creates a failed Result.\"\"\"\n    return cls(None, error, False)\n</code></pre>"},{"location":"reference/result/#fpstreams.Result.flat_map","title":"<code>flat_map(mapper)</code>","text":"<p>If Success, returns the result of applying the mapper (which must return a Result). If Failure, returns the existing Failure.</p> Source code in <code>fpstreams\\result.py</code> <pre><code>def flat_map(self, mapper: Callable[[T], \"Result[R]\"]) -&gt; \"Result[R]\":\n    \"\"\"\n    If Success, returns the result of applying the mapper (which must return a Result).\n    If Failure, returns the existing Failure.\n    \"\"\"\n    if self._is_success:\n        try:\n            val = cast(T, self._value)\n            return mapper(val)\n        except Exception as e:\n            return Result.failure(e)\n    return Result.failure(cast(Exception, self._error))\n</code></pre>"},{"location":"reference/result/#fpstreams.Result.get_or_else","title":"<code>get_or_else(default)</code>","text":"<p>Returns the value if Success, or the default value if Failure.</p> Source code in <code>fpstreams\\result.py</code> <pre><code>def get_or_else(self, default: T) -&gt; T:\n    \"\"\"Returns the value if Success, or the default value if Failure.\"\"\"\n    if self._is_success:\n        return cast(T, self._value)\n    return default\n</code></pre>"},{"location":"reference/result/#fpstreams.Result.get_or_throw","title":"<code>get_or_throw()</code>","text":"<p>Returns the value if Success, otherwise raises the stored exception.</p> Source code in <code>fpstreams\\result.py</code> <pre><code>def get_or_throw(self) -&gt; T:\n    \"\"\"Returns the value if Success, otherwise raises the stored exception.\"\"\"\n    if self._is_success:\n        return cast(T, self._value)\n    raise cast(Exception, self._error)\n</code></pre>"},{"location":"reference/result/#fpstreams.Result.map","title":"<code>map(mapper)</code>","text":"<p>If Success, applies the mapper to the value. If Failure, returns the existing Failure (skips the mapper).</p> Source code in <code>fpstreams\\result.py</code> <pre><code>def map(self, mapper: Callable[[T], R]) -&gt; \"Result[R]\":\n    \"\"\"\n    If Success, applies the mapper to the value.\n    If Failure, returns the existing Failure (skips the mapper).\n    \"\"\"\n    if self._is_success:\n        try:\n            val = cast(T, self._value)\n            return Result.success(mapper(val))\n        except Exception as e:\n            return Result.failure(e)\n    else:\n        return Result.failure(cast(Exception, self._error))\n</code></pre>"},{"location":"reference/result/#fpstreams.Result.map_error","title":"<code>map_error(mapper)</code>","text":"<p>If Failure, allows you to transform the exception. If Success, does nothing.</p> Source code in <code>fpstreams\\result.py</code> <pre><code>def map_error(self, mapper: Callable[[Exception], Exception]) -&gt; \"Result[T]\":\n    \"\"\"\n    If Failure, allows you to transform the exception.\n    If Success, does nothing.\n    \"\"\"\n    if not self._is_success:\n        err = cast(Exception, self._error)\n        return Result.failure(mapper(err))\n    return self\n</code></pre>"},{"location":"reference/result/#fpstreams.Result.of","title":"<code>of(func)</code>  <code>classmethod</code>","text":"<p>Executes the provided function.  Returns Success(value) if it works, or Failure(exception) if it crashes.</p> Source code in <code>fpstreams\\result.py</code> <pre><code>@classmethod\ndef of(cls, func: Callable[[], T]) -&gt; \"Result[T]\":\n    \"\"\"\n    Executes the provided function. \n    Returns Success(value) if it works, or Failure(exception) if it crashes.\n    \"\"\"\n    try:\n        return cls.success(func())\n    except Exception as e:\n        return cls.failure(e)\n</code></pre>"},{"location":"reference/result/#fpstreams.Result.on_failure","title":"<code>on_failure(action)</code>","text":"<p>Executes action if Failure.</p> Source code in <code>fpstreams\\result.py</code> <pre><code>def on_failure(self, action: Callable[[Exception], None]) -&gt; \"Result[T]\":\n    \"\"\"Executes action if Failure.\"\"\"\n    if not self._is_success:\n        action(cast(Exception, self._error))\n    return self\n</code></pre>"},{"location":"reference/result/#fpstreams.Result.on_success","title":"<code>on_success(action)</code>","text":"<p>Executes action if Success.</p> Source code in <code>fpstreams\\result.py</code> <pre><code>def on_success(self, action: Callable[[T], None]) -&gt; \"Result[T]\":\n    \"\"\"Executes action if Success.\"\"\"\n    if self._is_success:\n        action(cast(T, self._value))\n    return self\n</code></pre>"},{"location":"reference/result/#fpstreams.Result.success","title":"<code>success(value)</code>  <code>classmethod</code>","text":"<p>Creates a successful Result.</p> Source code in <code>fpstreams\\result.py</code> <pre><code>@classmethod\ndef success(cls, value: T) -&gt; \"Result[T]\":\n    \"\"\"Creates a successful Result.\"\"\"\n    return cls(value, None, True)\n</code></pre>"},{"location":"reference/stream/","title":"Stream API","text":"<p>               Bases: <code>Generic[T]</code></p> <p>A sequence of elements supporting sequential and aggregate operations. Inspired by Java Streams and JavaScript Array methods.</p> <p>This stream is lazy: intermediate operations (map, filter) are not executed until a terminal operation (to_list, reduce) is invoked.</p> Source code in <code>fpstreams\\stream.py</code> <pre><code>class Stream(Generic[T]):\n    \"\"\"\n    A sequence of elements supporting sequential and aggregate operations.\n    Inspired by Java Streams and JavaScript Array methods.\n\n    This stream is lazy: intermediate operations (map, filter) are not executed\n    until a terminal operation (to_list, reduce) is invoked.\n    \"\"\"\n\n    def __init__(self, iterable: Iterable[T]):\n        self._iterator: Iterator[T] = iter(iterable)\n\n    @classmethod\n    def of(cls, *args: T) -&gt; \"Stream[T]\":\n        \"\"\"Creates a Stream from specific iterables data structure.\"\"\"\n        return cls(args)\n\n    def map(self, mapper: Callable[[T], R]) -&gt; \"Stream[R]\":\n        \"\"\"Returns a stream consisting of the results of applying the given function.\"\"\"\n        return Stream(map(mapper, self._iterator))\n\n    def filter(self, predicate: Callable[[T], bool]) -&gt; \"Stream[T]\":\n        \"\"\"Returns a stream consisting of the elements that match the given predicate.\"\"\"\n        return Stream(filter(predicate, self._iterator))\n\n    def flat_map(self, mapper: Callable[[T], Iterable[R]]) -&gt; \"Stream[R]\":\n        \"\"\"\n        Returns a stream consisting of the results of replacing each element \n        with the contents of a mapped stream.\n        \"\"\"\n        mapped_iterators = map(mapper, self._iterator)\n        return Stream(itertools.chain.from_iterable(mapped_iterators))\n\n    def peek(self, action: Callable[[T], None]) -&gt; \"Stream[T]\":\n        \"\"\"\n        Performs the provided action on each element as elements are consumed\n        from the resulting stream.\n        \"\"\"\n        def peeking_generator():\n            for item in self._iterator:\n                action(item)\n                yield item\n        return Stream(peeking_generator())\n\n    def distinct(self) -&gt; \"Stream[T]\":\n        \"\"\"Returns a stream consisting of the distinct elements.\"\"\"\n        def distinct_generator():\n            distinct = set()\n            for item in self._iterator:\n                if item not in distinct:\n                    distinct.add(item)\n                    yield item\n        return Stream(distinct_generator())\n\n    def sorted(self, key: Optional[Callable[[T], Any]] = None, reverse: bool = False) -&gt; \"Stream[T]\":\n        \"\"\"\n        Returns a stream consisting of the elements of this stream, sorted.\n        \"\"\"\n        if key is None:\n            sortable_iter = cast(Iterator[SupportsRichComparison], self._iterator)\n            return Stream(cast(Iterator[T], sorted(sortable_iter, reverse=reverse)))\n        else:\n            return Stream(sorted(self._iterator, key=key, reverse=reverse))\n\n    def limit(self, max_size: int) -&gt; \"Stream[T]\":\n        \"\"\"Returns a stream consisting of the elements truncated to be no longer than max_size.\"\"\"\n        return Stream(itertools.islice(self._iterator, max_size))\n\n    def skip(self, n: int) -&gt; \"Stream[T]\":\n        \"\"\"Returns a stream consisting of the remaining elements after discarding the first n.\"\"\"\n        return Stream(itertools.islice(self._iterator, n, None))\n\n    def for_each(self, action: Callable[[T], None]) -&gt; None:\n        \"\"\"Performs an action for each element of this stream.\"\"\"\n        for item in self._iterator:\n            action(item)\n\n    def to_list(self) -&gt; List[T]:\n        \"\"\"Collects elements into a Python List.\"\"\"\n        return list(self._iterator)\n\n    def to_set(self) -&gt; Set[T]:\n        \"\"\"Collects elements into a Python Set.\"\"\"\n        return set(self._iterator)\n\n    def reduce(self, accumulator: Callable[[T, T], T], init: Union[T, None] = None) -&gt; Union[T, None]:\n        \"\"\"\n        Performs a reduction on the elements of this stream.\n        \"\"\"\n        if init is not None:\n            return functools.reduce(accumulator, self._iterator, init)\n\n        try:\n            return functools.reduce(accumulator, self._iterator)\n        except TypeError:\n            return None\n\n    def count(self) -&gt; int:\n        \"\"\"Returns the count of elements in this stream.\"\"\"\n        return sum(1 for _ in self._iterator)\n\n    def find_first(self) -&gt; \"Option[T]\":\n        \"\"\"\n        Returns an Option describing the first element of this stream, \n        or an empty Option if the stream is empty.\n        \"\"\"\n        try:\n            value = next(self._iterator)\n            return Option.of(value)\n        except StopIteration:\n            return Option.empty()\n\n    def any_match(self, predicate: Callable[[T], bool]) -&gt; bool:\n        \"\"\"Returns whether any elements of this stream match the provided predicate.\"\"\"\n        return any(predicate(item) for item in self._iterator)\n\n    def all_match(self, predicate: Callable[[T], bool]) -&gt; bool:\n        \"\"\"Returns whether all elements of this stream match the provided predicate.\"\"\"\n        return all(predicate(item) for item in self._iterator)\n\n    def none_match(self, predicate: Callable[[T], bool]) -&gt; bool:\n        \"\"\"Returns whether no elements of this stream match the provided predicate.\"\"\"\n        return not self.any_match(predicate)\n\n    def collect(self, collector: Callable[[Iterable[T]], R]) -&gt; R:\n        \"\"\"\n        Performs a mutable reduction operation on the elements of this stream.\n        \"\"\"\n        return collector(self._iterator)\n\n    def take_while(self, predicate: Callable[[T], bool]) -&gt; \"Stream[T]\":\n        \"\"\"\n        Returns a stream consisting of the longest prefix of elements \n        that satisfy the given predicate.\n        \"\"\"\n        return Stream(itertools.takewhile(predicate, self._iterator))\n\n    def drop_while(self, predicate: Callable[[T], bool]) -&gt; \"Stream[T]\":\n        \"\"\"\n        Returns a stream consisting of the remaining elements after dropping\n        the longest prefix of elements that satisfy the given predicate.\n        \"\"\"\n        return Stream(itertools.dropwhile(predicate, self._iterator))\n\n    def zip(self, other: Iterable[R]) -&gt; \"Stream[tuple[T, R]]\":\n        \"\"\"\n        Combines this stream with another iterable into a stream of pairs (tuples).\n        The stream stops when the shorter of the two runs out.\n        \"\"\"\n        return Stream(zip(self._iterator, other))\n\n    def zip_with_index(self) -&gt; \"Stream[tuple[int, T]]\":\n        \"\"\"\n        Returns a stream of (index, element) pairs.\n        \"\"\"\n        return Stream(enumerate(self._iterator))\n</code></pre>"},{"location":"reference/stream/#fpstreams.Stream.all_match","title":"<code>all_match(predicate)</code>","text":"<p>Returns whether all elements of this stream match the provided predicate.</p> Source code in <code>fpstreams\\stream.py</code> <pre><code>def all_match(self, predicate: Callable[[T], bool]) -&gt; bool:\n    \"\"\"Returns whether all elements of this stream match the provided predicate.\"\"\"\n    return all(predicate(item) for item in self._iterator)\n</code></pre>"},{"location":"reference/stream/#fpstreams.Stream.any_match","title":"<code>any_match(predicate)</code>","text":"<p>Returns whether any elements of this stream match the provided predicate.</p> Source code in <code>fpstreams\\stream.py</code> <pre><code>def any_match(self, predicate: Callable[[T], bool]) -&gt; bool:\n    \"\"\"Returns whether any elements of this stream match the provided predicate.\"\"\"\n    return any(predicate(item) for item in self._iterator)\n</code></pre>"},{"location":"reference/stream/#fpstreams.Stream.collect","title":"<code>collect(collector)</code>","text":"<p>Performs a mutable reduction operation on the elements of this stream.</p> Source code in <code>fpstreams\\stream.py</code> <pre><code>def collect(self, collector: Callable[[Iterable[T]], R]) -&gt; R:\n    \"\"\"\n    Performs a mutable reduction operation on the elements of this stream.\n    \"\"\"\n    return collector(self._iterator)\n</code></pre>"},{"location":"reference/stream/#fpstreams.Stream.count","title":"<code>count()</code>","text":"<p>Returns the count of elements in this stream.</p> Source code in <code>fpstreams\\stream.py</code> <pre><code>def count(self) -&gt; int:\n    \"\"\"Returns the count of elements in this stream.\"\"\"\n    return sum(1 for _ in self._iterator)\n</code></pre>"},{"location":"reference/stream/#fpstreams.Stream.distinct","title":"<code>distinct()</code>","text":"<p>Returns a stream consisting of the distinct elements.</p> Source code in <code>fpstreams\\stream.py</code> <pre><code>def distinct(self) -&gt; \"Stream[T]\":\n    \"\"\"Returns a stream consisting of the distinct elements.\"\"\"\n    def distinct_generator():\n        distinct = set()\n        for item in self._iterator:\n            if item not in distinct:\n                distinct.add(item)\n                yield item\n    return Stream(distinct_generator())\n</code></pre>"},{"location":"reference/stream/#fpstreams.Stream.drop_while","title":"<code>drop_while(predicate)</code>","text":"<p>Returns a stream consisting of the remaining elements after dropping the longest prefix of elements that satisfy the given predicate.</p> Source code in <code>fpstreams\\stream.py</code> <pre><code>def drop_while(self, predicate: Callable[[T], bool]) -&gt; \"Stream[T]\":\n    \"\"\"\n    Returns a stream consisting of the remaining elements after dropping\n    the longest prefix of elements that satisfy the given predicate.\n    \"\"\"\n    return Stream(itertools.dropwhile(predicate, self._iterator))\n</code></pre>"},{"location":"reference/stream/#fpstreams.Stream.filter","title":"<code>filter(predicate)</code>","text":"<p>Returns a stream consisting of the elements that match the given predicate.</p> Source code in <code>fpstreams\\stream.py</code> <pre><code>def filter(self, predicate: Callable[[T], bool]) -&gt; \"Stream[T]\":\n    \"\"\"Returns a stream consisting of the elements that match the given predicate.\"\"\"\n    return Stream(filter(predicate, self._iterator))\n</code></pre>"},{"location":"reference/stream/#fpstreams.Stream.find_first","title":"<code>find_first()</code>","text":"<p>Returns an Option describing the first element of this stream,  or an empty Option if the stream is empty.</p> Source code in <code>fpstreams\\stream.py</code> <pre><code>def find_first(self) -&gt; \"Option[T]\":\n    \"\"\"\n    Returns an Option describing the first element of this stream, \n    or an empty Option if the stream is empty.\n    \"\"\"\n    try:\n        value = next(self._iterator)\n        return Option.of(value)\n    except StopIteration:\n        return Option.empty()\n</code></pre>"},{"location":"reference/stream/#fpstreams.Stream.flat_map","title":"<code>flat_map(mapper)</code>","text":"<p>Returns a stream consisting of the results of replacing each element  with the contents of a mapped stream.</p> Source code in <code>fpstreams\\stream.py</code> <pre><code>def flat_map(self, mapper: Callable[[T], Iterable[R]]) -&gt; \"Stream[R]\":\n    \"\"\"\n    Returns a stream consisting of the results of replacing each element \n    with the contents of a mapped stream.\n    \"\"\"\n    mapped_iterators = map(mapper, self._iterator)\n    return Stream(itertools.chain.from_iterable(mapped_iterators))\n</code></pre>"},{"location":"reference/stream/#fpstreams.Stream.for_each","title":"<code>for_each(action)</code>","text":"<p>Performs an action for each element of this stream.</p> Source code in <code>fpstreams\\stream.py</code> <pre><code>def for_each(self, action: Callable[[T], None]) -&gt; None:\n    \"\"\"Performs an action for each element of this stream.\"\"\"\n    for item in self._iterator:\n        action(item)\n</code></pre>"},{"location":"reference/stream/#fpstreams.Stream.limit","title":"<code>limit(max_size)</code>","text":"<p>Returns a stream consisting of the elements truncated to be no longer than max_size.</p> Source code in <code>fpstreams\\stream.py</code> <pre><code>def limit(self, max_size: int) -&gt; \"Stream[T]\":\n    \"\"\"Returns a stream consisting of the elements truncated to be no longer than max_size.\"\"\"\n    return Stream(itertools.islice(self._iterator, max_size))\n</code></pre>"},{"location":"reference/stream/#fpstreams.Stream.map","title":"<code>map(mapper)</code>","text":"<p>Returns a stream consisting of the results of applying the given function.</p> Source code in <code>fpstreams\\stream.py</code> <pre><code>def map(self, mapper: Callable[[T], R]) -&gt; \"Stream[R]\":\n    \"\"\"Returns a stream consisting of the results of applying the given function.\"\"\"\n    return Stream(map(mapper, self._iterator))\n</code></pre>"},{"location":"reference/stream/#fpstreams.Stream.none_match","title":"<code>none_match(predicate)</code>","text":"<p>Returns whether no elements of this stream match the provided predicate.</p> Source code in <code>fpstreams\\stream.py</code> <pre><code>def none_match(self, predicate: Callable[[T], bool]) -&gt; bool:\n    \"\"\"Returns whether no elements of this stream match the provided predicate.\"\"\"\n    return not self.any_match(predicate)\n</code></pre>"},{"location":"reference/stream/#fpstreams.Stream.of","title":"<code>of(*args)</code>  <code>classmethod</code>","text":"<p>Creates a Stream from specific iterables data structure.</p> Source code in <code>fpstreams\\stream.py</code> <pre><code>@classmethod\ndef of(cls, *args: T) -&gt; \"Stream[T]\":\n    \"\"\"Creates a Stream from specific iterables data structure.\"\"\"\n    return cls(args)\n</code></pre>"},{"location":"reference/stream/#fpstreams.Stream.peek","title":"<code>peek(action)</code>","text":"<p>Performs the provided action on each element as elements are consumed from the resulting stream.</p> Source code in <code>fpstreams\\stream.py</code> <pre><code>def peek(self, action: Callable[[T], None]) -&gt; \"Stream[T]\":\n    \"\"\"\n    Performs the provided action on each element as elements are consumed\n    from the resulting stream.\n    \"\"\"\n    def peeking_generator():\n        for item in self._iterator:\n            action(item)\n            yield item\n    return Stream(peeking_generator())\n</code></pre>"},{"location":"reference/stream/#fpstreams.Stream.reduce","title":"<code>reduce(accumulator, init=None)</code>","text":"<p>Performs a reduction on the elements of this stream.</p> Source code in <code>fpstreams\\stream.py</code> <pre><code>def reduce(self, accumulator: Callable[[T, T], T], init: Union[T, None] = None) -&gt; Union[T, None]:\n    \"\"\"\n    Performs a reduction on the elements of this stream.\n    \"\"\"\n    if init is not None:\n        return functools.reduce(accumulator, self._iterator, init)\n\n    try:\n        return functools.reduce(accumulator, self._iterator)\n    except TypeError:\n        return None\n</code></pre>"},{"location":"reference/stream/#fpstreams.Stream.skip","title":"<code>skip(n)</code>","text":"<p>Returns a stream consisting of the remaining elements after discarding the first n.</p> Source code in <code>fpstreams\\stream.py</code> <pre><code>def skip(self, n: int) -&gt; \"Stream[T]\":\n    \"\"\"Returns a stream consisting of the remaining elements after discarding the first n.\"\"\"\n    return Stream(itertools.islice(self._iterator, n, None))\n</code></pre>"},{"location":"reference/stream/#fpstreams.Stream.sorted","title":"<code>sorted(key=None, reverse=False)</code>","text":"<p>Returns a stream consisting of the elements of this stream, sorted.</p> Source code in <code>fpstreams\\stream.py</code> <pre><code>def sorted(self, key: Optional[Callable[[T], Any]] = None, reverse: bool = False) -&gt; \"Stream[T]\":\n    \"\"\"\n    Returns a stream consisting of the elements of this stream, sorted.\n    \"\"\"\n    if key is None:\n        sortable_iter = cast(Iterator[SupportsRichComparison], self._iterator)\n        return Stream(cast(Iterator[T], sorted(sortable_iter, reverse=reverse)))\n    else:\n        return Stream(sorted(self._iterator, key=key, reverse=reverse))\n</code></pre>"},{"location":"reference/stream/#fpstreams.Stream.take_while","title":"<code>take_while(predicate)</code>","text":"<p>Returns a stream consisting of the longest prefix of elements  that satisfy the given predicate.</p> Source code in <code>fpstreams\\stream.py</code> <pre><code>def take_while(self, predicate: Callable[[T], bool]) -&gt; \"Stream[T]\":\n    \"\"\"\n    Returns a stream consisting of the longest prefix of elements \n    that satisfy the given predicate.\n    \"\"\"\n    return Stream(itertools.takewhile(predicate, self._iterator))\n</code></pre>"},{"location":"reference/stream/#fpstreams.Stream.to_list","title":"<code>to_list()</code>","text":"<p>Collects elements into a Python List.</p> Source code in <code>fpstreams\\stream.py</code> <pre><code>def to_list(self) -&gt; List[T]:\n    \"\"\"Collects elements into a Python List.\"\"\"\n    return list(self._iterator)\n</code></pre>"},{"location":"reference/stream/#fpstreams.Stream.to_set","title":"<code>to_set()</code>","text":"<p>Collects elements into a Python Set.</p> Source code in <code>fpstreams\\stream.py</code> <pre><code>def to_set(self) -&gt; Set[T]:\n    \"\"\"Collects elements into a Python Set.\"\"\"\n    return set(self._iterator)\n</code></pre>"},{"location":"reference/stream/#fpstreams.Stream.zip","title":"<code>zip(other)</code>","text":"<p>Combines this stream with another iterable into a stream of pairs (tuples). The stream stops when the shorter of the two runs out.</p> Source code in <code>fpstreams\\stream.py</code> <pre><code>def zip(self, other: Iterable[R]) -&gt; \"Stream[tuple[T, R]]\":\n    \"\"\"\n    Combines this stream with another iterable into a stream of pairs (tuples).\n    The stream stops when the shorter of the two runs out.\n    \"\"\"\n    return Stream(zip(self._iterator, other))\n</code></pre>"},{"location":"reference/stream/#fpstreams.Stream.zip_with_index","title":"<code>zip_with_index()</code>","text":"<p>Returns a stream of (index, element) pairs.</p> Source code in <code>fpstreams\\stream.py</code> <pre><code>def zip_with_index(self) -&gt; \"Stream[tuple[int, T]]\":\n    \"\"\"\n    Returns a stream of (index, element) pairs.\n    \"\"\"\n    return Stream(enumerate(self._iterator))\n</code></pre>"}]}