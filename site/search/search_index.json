{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"fpstreams","text":"<p>A robust, type-safe functional programming library for Python.</p> <p><code>fpstreams</code> brings the power of Java Streams, Rust Results, and JavaScript Array methods to Python. It provides a fluent interface for data processing, null safety, and error handling without the boilerplate, all while remaining fully typed for IDE autocompletion.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Fluent Streams: Lazy evaluation chains (<code>map</code>, <code>filter</code>, <code>reduce</code>, <code>zip</code>)</li> <li>Null Safety: <code>Option</code> monad to eliminate <code>None</code> checks.</li> <li>Error Handling: <code>Result</code> monad (Success/Failure) to replace ugly <code>try/except</code> blocks.</li> <li>Powerful Collectors: Grouping, partitioning, and joining made simple.</li> <li>Functional Tools: Utilities like <code>pipe</code> and <code>curry</code> for cleaner composition.</li> </ul>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install fpstreams\n</code></pre> <p>Comparison between standard streams and <code>fpstreams.parallel()</code> on a 4-core machine:</p> Task Sequential Parallel Speedup Heavy Calculation (Factorials) 21.10s 8.25s 2.56x I/O Simulation (Requests) 2.08s 0.73s 2.87x <p>Note: Parallelism has overhead. Use <code>.parallel()</code> only for computationally intensive tasks or large datasets.</p>"},{"location":"#usage-example","title":"Usage Example","text":""},{"location":"#streams-using-name-from-java","title":"Streams (using name from Java)","text":"<pre><code>from fpstreams import Stream\n\ndata = [\n    {\"name\": \"Alice\", \"role\": \"admin\", \"age\": 30},\n    {\"name\": \"Bob\", \"role\": \"dev\", \"age\": 25},\n    {\"name\": \"Charlie\", \"role\": \"admin\", \"age\": 45}\n]\n\n# Get names of admins whose age is over 25, sorted alphabetically\nnames = (\n    Stream(data)\n    .filter(lambda u: u[\"role\"] == \"admin\")\n    .filter(lambda u: u[\"age\"] &gt; 25)\n    .map(lambda u: u[\"name\"].upper())\n    .sorted()\n    .to_list()\n)\n# Output: ['ALICE', 'CHARLIE']\n</code></pre>"},{"location":"#null-safety-with-option","title":"Null Safety with <code>Option</code>","text":"<pre><code>from fpstreams import Stream\n\n# Find the first user named \"Steven\" (who doesn't exist)\nemail = (\n    Stream(data)\n    .filter(lambda u: u[\"name\"] == \"Steven\")\n    .find_first()               # Returns Option[User]\n    .map(lambda u: u[\"email\"])  # Skipped because Option is empty\n    .or_else(\"default@example.com\")\n)\n</code></pre>"},{"location":"#error-handling-with-result","title":"Error handling with <code>Result</code>","text":"<pre><code>from fpstreams import Result\n\ndef risky_parsing(value):\n    return int(value) # Might crash if value is not a number\n\n# Safe execution\nresult = (\n    Result.of(lambda: risky_parsing(\"invalid\"))\n    .map(lambda x: x * 2)\n    .on_failure(lambda e: print(f\"Parsing failed: {e}\")) # Logs error\n    .get_or_else(0) # Returns 0 instead of crashing\n)\n</code></pre>"},{"location":"#collectors","title":"Collectors","text":"<p>grouping data using collectors</p> <pre><code>from fpstreams import Stream, Collectors\n\nfruits = [\"apple\", \"avocado\", \"banana\", \"blueberry\", \"cherry\"]\n\n# Group fruits by their first letter\ngrouped = (\n    Stream(fruits)\n    .collect(Collectors.grouping_by(lambda s: s[0]))\n)\n# Output: {'a': ['apple', 'avocado'], 'b': ['banana', 'blueberry'], 'c': ['cherry']}\n</code></pre>"},{"location":"#infinite-streams-lazy-evaluation","title":"Infinite Streams &amp; Lazy Evaluation","text":"<p>Process massive datasets efficiently. Operations are only executed when needed.</p> <pre><code>def infinite_counter():\n    n = 0\n    while True:\n        yield n\n        n += 1\n\n# Take only the first 10 even numbers\nevens = (\n    Stream(infinite_counter())\n    .filter(lambda x: x % 2 == 0)\n    .limit(10)\n    .to_list()\n)\n</code></pre>"},{"location":"#parallel-processing","title":"Parallel Processing","text":"<p>fpstreams can automatically distribute heavy workloads across all CPU cores using the <code>.parallel()</code> method. It uses an optimized Map-Reduce architecture to minimize memory usage.</p> <pre><code>from fpstreams import Stream\n\ndef heavy_task(x):\n    return x ** 5000\n\n# Automatically uses all available CPU cores\nresults = (\n    Stream(range(10000))\n    .parallel()\n    .map(heavy_task)\n    .to_list()\n)\n</code></pre>"},{"location":"#project-structure","title":"Project Structure","text":"<ul> <li><code>Stream</code>: The core wrapper for sequential data processing.</li> <li><code>ParallelStream</code>: A multi-core wrapper for heavy parallel processing.</li> <li><code>Option</code>: A monad container for optional values (Null Safety).</li> <li><code>Result</code>: A monad container for operations that may fail (Error Handling).</li> <li><code>Collectors</code>: Helper functions for aggregation (e.g., <code>grouping_by</code>, <code>partitioning_by</code>).</li> <li><code>functional</code>: Utilities like <code>pipe</code> and <code>curry</code> for functional composition.</li> </ul>"},{"location":"reference/option/","title":"Option API","text":"<p>               Bases: <code>Generic[T]</code></p> <p>A container object which may or may not contain a non-null value. Replaces None checks.</p> Source code in <code>src\\fpstreams\\option.py</code> <pre><code>class Option(Generic[T]):\n    \"\"\"\n    A container object which may or may not contain a non-null value.\n    Replaces None checks.\n    \"\"\"\n\n    def __init__(self, value: Union[T, None]):\n        self._value = value\n\n    @classmethod\n    def of(cls, value: T) -&gt; \"Option[T]\":\n        \"\"\"Returns an Option describing the given non-null value.\"\"\"\n        if value is None:\n            raise ValueError(\"Option.of() cannot be called with None. Use Option.of_nullable() instead.\")\n        return cls(value)\n\n    @classmethod\n    def of_nullable(cls, value: Union[T, None]) -&gt; \"Option[T]\":\n        \"\"\"Returns an Option describing the given value, if non-null, otherwise returns an empty Option.\"\"\"\n        return cls(value)\n\n    @classmethod\n    def empty(cls) -&gt; \"Option[T]\":\n        \"\"\"Returns an empty Option instance.\"\"\"\n        return cls(None)\n\n    def is_present(self) -&gt; bool:\n        \"\"\"Returns True if there is a value present, otherwise False.\"\"\"\n        return self._value is not None\n\n    def is_empty(self) -&gt; bool:\n        \"\"\"Returns True if there is no value present, otherwise False.\"\"\"\n        return self._value is None\n\n    def if_present(self, action: Callable[[T], None]) -&gt; None:\n        \"\"\"If a value is present, invokes the specified consumer with the value, otherwise does nothing.\"\"\"\n        if self._value is not None:\n            action(self._value)\n\n    def filter(self, predicate: Callable[[T], bool]) -&gt; \"Option[T]\":\n        \"\"\"\n        If a value is present and matches the given predicate, return an Option describing the value,\n        otherwise return an empty Option.\n        \"\"\"\n        if self._value is None:\n            return self\n\n        if predicate(self._value):\n            return self\n        return Option.empty()\n\n    def map(self, mapper: Callable[[T], R]) -&gt; \"Option[R]\":\n        \"\"\"\n        If a value is present, apply the provided mapping function to it, \n        and if the result is non-null, return an Option describing the result.\n        \"\"\"\n        if self._value is None:\n            return Option.empty()\n\n        result = mapper(self._value)\n        return Option.of_nullable(result)\n\n    def flat_map(self, mapper: Callable[[T], \"Option[R]\"]) -&gt; \"Option[R]\":\n        \"\"\"\n        If a value is present, apply the provided Option-bearing mapping function to it, \n        return that result, otherwise return an empty Option.\n        \"\"\"\n        if self._value is None:\n            return Option.empty()\n\n        return mapper(self._value)\n\n    def or_else(self, other: T) -&gt; T:\n        \"\"\"Return the value if present, otherwise return other.\"\"\"\n        return self._value if self._value is not None else other\n\n    def or_else_get(self, supplier: Callable[[], T]) -&gt; T:\n        \"\"\"Return the value if present, otherwise invoke other and return the result of that invocation.\"\"\"\n        return self._value if self._value is not None else supplier()\n\n    def or_else_throw(self, exception_supplier: Callable[[], Exception]) -&gt; T:\n        \"\"\"Return the contained value, if present, otherwise throw an exception to be created by the provided supplier.\"\"\"\n        if self._value is not None:\n            return self._value\n        raise exception_supplier()\n\n    def __repr__(self) -&gt; str:\n        return f\"Option({self._value})\" if self._value is not None else \"Option.empty\"\n\n    def __bool__(self) -&gt; bool:\n        return self._value is not None\n</code></pre>"},{"location":"reference/option/#fpstreams.Option.empty","title":"<code>empty()</code>  <code>classmethod</code>","text":"<p>Returns an empty Option instance.</p> Source code in <code>src\\fpstreams\\option.py</code> <pre><code>@classmethod\ndef empty(cls) -&gt; \"Option[T]\":\n    \"\"\"Returns an empty Option instance.\"\"\"\n    return cls(None)\n</code></pre>"},{"location":"reference/option/#fpstreams.Option.filter","title":"<code>filter(predicate)</code>","text":"<p>If a value is present and matches the given predicate, return an Option describing the value, otherwise return an empty Option.</p> Source code in <code>src\\fpstreams\\option.py</code> <pre><code>def filter(self, predicate: Callable[[T], bool]) -&gt; \"Option[T]\":\n    \"\"\"\n    If a value is present and matches the given predicate, return an Option describing the value,\n    otherwise return an empty Option.\n    \"\"\"\n    if self._value is None:\n        return self\n\n    if predicate(self._value):\n        return self\n    return Option.empty()\n</code></pre>"},{"location":"reference/option/#fpstreams.Option.flat_map","title":"<code>flat_map(mapper)</code>","text":"<p>If a value is present, apply the provided Option-bearing mapping function to it,  return that result, otherwise return an empty Option.</p> Source code in <code>src\\fpstreams\\option.py</code> <pre><code>def flat_map(self, mapper: Callable[[T], \"Option[R]\"]) -&gt; \"Option[R]\":\n    \"\"\"\n    If a value is present, apply the provided Option-bearing mapping function to it, \n    return that result, otherwise return an empty Option.\n    \"\"\"\n    if self._value is None:\n        return Option.empty()\n\n    return mapper(self._value)\n</code></pre>"},{"location":"reference/option/#fpstreams.Option.if_present","title":"<code>if_present(action)</code>","text":"<p>If a value is present, invokes the specified consumer with the value, otherwise does nothing.</p> Source code in <code>src\\fpstreams\\option.py</code> <pre><code>def if_present(self, action: Callable[[T], None]) -&gt; None:\n    \"\"\"If a value is present, invokes the specified consumer with the value, otherwise does nothing.\"\"\"\n    if self._value is not None:\n        action(self._value)\n</code></pre>"},{"location":"reference/option/#fpstreams.Option.is_empty","title":"<code>is_empty()</code>","text":"<p>Returns True if there is no value present, otherwise False.</p> Source code in <code>src\\fpstreams\\option.py</code> <pre><code>def is_empty(self) -&gt; bool:\n    \"\"\"Returns True if there is no value present, otherwise False.\"\"\"\n    return self._value is None\n</code></pre>"},{"location":"reference/option/#fpstreams.Option.is_present","title":"<code>is_present()</code>","text":"<p>Returns True if there is a value present, otherwise False.</p> Source code in <code>src\\fpstreams\\option.py</code> <pre><code>def is_present(self) -&gt; bool:\n    \"\"\"Returns True if there is a value present, otherwise False.\"\"\"\n    return self._value is not None\n</code></pre>"},{"location":"reference/option/#fpstreams.Option.map","title":"<code>map(mapper)</code>","text":"<p>If a value is present, apply the provided mapping function to it,  and if the result is non-null, return an Option describing the result.</p> Source code in <code>src\\fpstreams\\option.py</code> <pre><code>def map(self, mapper: Callable[[T], R]) -&gt; \"Option[R]\":\n    \"\"\"\n    If a value is present, apply the provided mapping function to it, \n    and if the result is non-null, return an Option describing the result.\n    \"\"\"\n    if self._value is None:\n        return Option.empty()\n\n    result = mapper(self._value)\n    return Option.of_nullable(result)\n</code></pre>"},{"location":"reference/option/#fpstreams.Option.of","title":"<code>of(value)</code>  <code>classmethod</code>","text":"<p>Returns an Option describing the given non-null value.</p> Source code in <code>src\\fpstreams\\option.py</code> <pre><code>@classmethod\ndef of(cls, value: T) -&gt; \"Option[T]\":\n    \"\"\"Returns an Option describing the given non-null value.\"\"\"\n    if value is None:\n        raise ValueError(\"Option.of() cannot be called with None. Use Option.of_nullable() instead.\")\n    return cls(value)\n</code></pre>"},{"location":"reference/option/#fpstreams.Option.of_nullable","title":"<code>of_nullable(value)</code>  <code>classmethod</code>","text":"<p>Returns an Option describing the given value, if non-null, otherwise returns an empty Option.</p> Source code in <code>src\\fpstreams\\option.py</code> <pre><code>@classmethod\ndef of_nullable(cls, value: Union[T, None]) -&gt; \"Option[T]\":\n    \"\"\"Returns an Option describing the given value, if non-null, otherwise returns an empty Option.\"\"\"\n    return cls(value)\n</code></pre>"},{"location":"reference/option/#fpstreams.Option.or_else","title":"<code>or_else(other)</code>","text":"<p>Return the value if present, otherwise return other.</p> Source code in <code>src\\fpstreams\\option.py</code> <pre><code>def or_else(self, other: T) -&gt; T:\n    \"\"\"Return the value if present, otherwise return other.\"\"\"\n    return self._value if self._value is not None else other\n</code></pre>"},{"location":"reference/option/#fpstreams.Option.or_else_get","title":"<code>or_else_get(supplier)</code>","text":"<p>Return the value if present, otherwise invoke other and return the result of that invocation.</p> Source code in <code>src\\fpstreams\\option.py</code> <pre><code>def or_else_get(self, supplier: Callable[[], T]) -&gt; T:\n    \"\"\"Return the value if present, otherwise invoke other and return the result of that invocation.\"\"\"\n    return self._value if self._value is not None else supplier()\n</code></pre>"},{"location":"reference/option/#fpstreams.Option.or_else_throw","title":"<code>or_else_throw(exception_supplier)</code>","text":"<p>Return the contained value, if present, otherwise throw an exception to be created by the provided supplier.</p> Source code in <code>src\\fpstreams\\option.py</code> <pre><code>def or_else_throw(self, exception_supplier: Callable[[], Exception]) -&gt; T:\n    \"\"\"Return the contained value, if present, otherwise throw an exception to be created by the provided supplier.\"\"\"\n    if self._value is not None:\n        return self._value\n    raise exception_supplier()\n</code></pre>"},{"location":"reference/parallel/","title":"ParallelStream API","text":""},{"location":"reference/parallel/#fpstreams.ParallelStream","title":"<code>fpstreams.ParallelStream</code>","text":"<p>               Bases: <code>BaseStream[T]</code></p>"},{"location":"reference/result/","title":"Result API","text":"<p>               Bases: <code>Generic[T]</code></p> <p>A container for a value that represents either a successful result (Success) or a failure (Failure).  Replaces try/except blocks in functional pipelines.</p> Source code in <code>src\\fpstreams\\result.py</code> <pre><code>class Result(Generic[T]):\n    \"\"\"\n    A container for a value that represents either a successful result (Success)\n    or a failure (Failure). \n    Replaces try/except blocks in functional pipelines.\n    \"\"\"\n\n    def __init__(self, value: Union[T, None], error: Union[Exception, None], is_success: bool):\n        self._value = value\n        self._error = error\n        self._is_success = is_success\n\n    @classmethod\n    def success(cls, value: T) -&gt; \"Result[T]\":\n        \"\"\"Creates a successful Result.\"\"\"\n        return cls(value, None, True)\n\n    @classmethod\n    def failure(cls, error: Exception) -&gt; \"Result[T]\":\n        \"\"\"Creates a failed Result.\"\"\"\n        return cls(None, error, False)\n\n    @classmethod\n    def of(cls, func: Callable[[], T]) -&gt; \"Result[T]\":\n        \"\"\"\n        Executes the provided function. \n        Returns Success(value) if it works, or Failure(exception) if it crashes.\n        \"\"\"\n        try:\n            return cls.success(func())\n        except Exception as e:\n            return cls.failure(e)\n\n    def is_success(self) -&gt; bool:\n        return self._is_success\n\n    def is_failure(self) -&gt; bool:\n        return not self._is_success\n\n    def map(self, mapper: Callable[[T], R]) -&gt; \"Result[R]\":\n        \"\"\"\n        If Success, applies the mapper to the value.\n        If Failure, returns the existing Failure (skips the mapper).\n        \"\"\"\n        if self._is_success:\n            try:\n                val = cast(T, self._value)\n                return Result.success(mapper(val))\n            except Exception as e:\n                return Result.failure(e)\n        else:\n            return Result.failure(cast(Exception, self._error))\n\n    def flat_map(self, mapper: Callable[[T], \"Result[R]\"]) -&gt; \"Result[R]\":\n        \"\"\"\n        If Success, returns the result of applying the mapper (which must return a Result).\n        If Failure, returns the existing Failure.\n        \"\"\"\n        if self._is_success:\n            try:\n                val = cast(T, self._value)\n                return mapper(val)\n            except Exception as e:\n                return Result.failure(e)\n        return Result.failure(cast(Exception, self._error))\n\n    def map_error(self, mapper: Callable[[Exception], Exception]) -&gt; \"Result[T]\":\n        \"\"\"\n        If Failure, allows you to transform the exception.\n        If Success, does nothing.\n        \"\"\"\n        if not self._is_success:\n            err = cast(Exception, self._error)\n            return Result.failure(mapper(err))\n        return self\n\n    def on_success(self, action: Callable[[T], None]) -&gt; \"Result[T]\":\n        \"\"\"Executes action if Success.\"\"\"\n        if self._is_success:\n            action(cast(T, self._value))\n        return self\n\n    def on_failure(self, action: Callable[[Exception], None]) -&gt; \"Result[T]\":\n        \"\"\"Executes action if Failure.\"\"\"\n        if not self._is_success:\n            action(cast(Exception, self._error))\n        return self\n\n    def get_or_else(self, default: T) -&gt; T:\n        \"\"\"Returns the value if Success, or the default value if Failure.\"\"\"\n        if self._is_success:\n            return cast(T, self._value)\n        return default\n\n    def get_or_throw(self) -&gt; T:\n        \"\"\"Returns the value if Success, otherwise raises the stored exception.\"\"\"\n        if self._is_success:\n            return cast(T, self._value)\n        raise cast(Exception, self._error)\n\n    def __repr__(self) -&gt; str:\n        if self._is_success:\n            return f\"Result.success({self._value})\"\n        return f\"Result.failure({self._error})\"\n</code></pre>"},{"location":"reference/result/#fpstreams.Result.failure","title":"<code>failure(error)</code>  <code>classmethod</code>","text":"<p>Creates a failed Result.</p> Source code in <code>src\\fpstreams\\result.py</code> <pre><code>@classmethod\ndef failure(cls, error: Exception) -&gt; \"Result[T]\":\n    \"\"\"Creates a failed Result.\"\"\"\n    return cls(None, error, False)\n</code></pre>"},{"location":"reference/result/#fpstreams.Result.flat_map","title":"<code>flat_map(mapper)</code>","text":"<p>If Success, returns the result of applying the mapper (which must return a Result). If Failure, returns the existing Failure.</p> Source code in <code>src\\fpstreams\\result.py</code> <pre><code>def flat_map(self, mapper: Callable[[T], \"Result[R]\"]) -&gt; \"Result[R]\":\n    \"\"\"\n    If Success, returns the result of applying the mapper (which must return a Result).\n    If Failure, returns the existing Failure.\n    \"\"\"\n    if self._is_success:\n        try:\n            val = cast(T, self._value)\n            return mapper(val)\n        except Exception as e:\n            return Result.failure(e)\n    return Result.failure(cast(Exception, self._error))\n</code></pre>"},{"location":"reference/result/#fpstreams.Result.get_or_else","title":"<code>get_or_else(default)</code>","text":"<p>Returns the value if Success, or the default value if Failure.</p> Source code in <code>src\\fpstreams\\result.py</code> <pre><code>def get_or_else(self, default: T) -&gt; T:\n    \"\"\"Returns the value if Success, or the default value if Failure.\"\"\"\n    if self._is_success:\n        return cast(T, self._value)\n    return default\n</code></pre>"},{"location":"reference/result/#fpstreams.Result.get_or_throw","title":"<code>get_or_throw()</code>","text":"<p>Returns the value if Success, otherwise raises the stored exception.</p> Source code in <code>src\\fpstreams\\result.py</code> <pre><code>def get_or_throw(self) -&gt; T:\n    \"\"\"Returns the value if Success, otherwise raises the stored exception.\"\"\"\n    if self._is_success:\n        return cast(T, self._value)\n    raise cast(Exception, self._error)\n</code></pre>"},{"location":"reference/result/#fpstreams.Result.map","title":"<code>map(mapper)</code>","text":"<p>If Success, applies the mapper to the value. If Failure, returns the existing Failure (skips the mapper).</p> Source code in <code>src\\fpstreams\\result.py</code> <pre><code>def map(self, mapper: Callable[[T], R]) -&gt; \"Result[R]\":\n    \"\"\"\n    If Success, applies the mapper to the value.\n    If Failure, returns the existing Failure (skips the mapper).\n    \"\"\"\n    if self._is_success:\n        try:\n            val = cast(T, self._value)\n            return Result.success(mapper(val))\n        except Exception as e:\n            return Result.failure(e)\n    else:\n        return Result.failure(cast(Exception, self._error))\n</code></pre>"},{"location":"reference/result/#fpstreams.Result.map_error","title":"<code>map_error(mapper)</code>","text":"<p>If Failure, allows you to transform the exception. If Success, does nothing.</p> Source code in <code>src\\fpstreams\\result.py</code> <pre><code>def map_error(self, mapper: Callable[[Exception], Exception]) -&gt; \"Result[T]\":\n    \"\"\"\n    If Failure, allows you to transform the exception.\n    If Success, does nothing.\n    \"\"\"\n    if not self._is_success:\n        err = cast(Exception, self._error)\n        return Result.failure(mapper(err))\n    return self\n</code></pre>"},{"location":"reference/result/#fpstreams.Result.of","title":"<code>of(func)</code>  <code>classmethod</code>","text":"<p>Executes the provided function.  Returns Success(value) if it works, or Failure(exception) if it crashes.</p> Source code in <code>src\\fpstreams\\result.py</code> <pre><code>@classmethod\ndef of(cls, func: Callable[[], T]) -&gt; \"Result[T]\":\n    \"\"\"\n    Executes the provided function. \n    Returns Success(value) if it works, or Failure(exception) if it crashes.\n    \"\"\"\n    try:\n        return cls.success(func())\n    except Exception as e:\n        return cls.failure(e)\n</code></pre>"},{"location":"reference/result/#fpstreams.Result.on_failure","title":"<code>on_failure(action)</code>","text":"<p>Executes action if Failure.</p> Source code in <code>src\\fpstreams\\result.py</code> <pre><code>def on_failure(self, action: Callable[[Exception], None]) -&gt; \"Result[T]\":\n    \"\"\"Executes action if Failure.\"\"\"\n    if not self._is_success:\n        action(cast(Exception, self._error))\n    return self\n</code></pre>"},{"location":"reference/result/#fpstreams.Result.on_success","title":"<code>on_success(action)</code>","text":"<p>Executes action if Success.</p> Source code in <code>src\\fpstreams\\result.py</code> <pre><code>def on_success(self, action: Callable[[T], None]) -&gt; \"Result[T]\":\n    \"\"\"Executes action if Success.\"\"\"\n    if self._is_success:\n        action(cast(T, self._value))\n    return self\n</code></pre>"},{"location":"reference/result/#fpstreams.Result.success","title":"<code>success(value)</code>  <code>classmethod</code>","text":"<p>Creates a successful Result.</p> Source code in <code>src\\fpstreams\\result.py</code> <pre><code>@classmethod\ndef success(cls, value: T) -&gt; \"Result[T]\":\n    \"\"\"Creates a successful Result.\"\"\"\n    return cls(value, None, True)\n</code></pre>"},{"location":"reference/stream/","title":"Stream API","text":""},{"location":"reference/stream/#fpstreams.Stream","title":"<code>fpstreams.Stream</code>","text":"<p>               Bases: <code>BaseStream[T]</code></p>"}]}